// ==========================================================================
//                      DG.GlobalFormulaContext
//  
//  Author:   Kirk Swenson
//
//  Copyright (c) 2014 by The Concord Consortium, Inc. All rights reserved.
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.
// ==========================================================================

sc_require('formula/formula_context');

/** @class DG.GlobalFormulaContext

  DG.FormulaContext objects support DG.Formula objects by providing identifier
  binding and evaluation, function binding and evaluation, etc.
  The DG.GlobalFormulaContext class adds binding to global (slider) values.

  @extends DG.FormulaContext
*/
DG.GlobalFormulaContext = DG.FormulaContext.extend({

  /**
    Compiles a variable reference into the JavaScript code for accessing
    the appropriate value. For the PlottedFunctionContext, this means
    binding to 'x' and any global values (e.g. sliders).
    @param    {String}    iName -- The variable name to be bound
    @returns  {String}    The JavaScript code for accessing the value
    @throws   {VarReferenceError} Base class throws VarReferenceError for
                                  variable names that are not recognized.
   */
  compileVariable: function( iName) {
  
    // Check for a match with any global variables (e.g. sliders)
    var globalValue = DG.globalsController.getGlobalValueByName( iName);
    if( globalValue) {
      // register the dependency for tracking/invalidation purposes
      this.registerDependency({ independentSpec: {
                                  type: DG.DEP_TYPE_GLOBAL,
                                  id: globalValue.get('id'),
                                  name: iName }
                              });

      // Having identified the global value to be referenced, we attach
      // a function that can access the appropriate value, making use of
      // JavaScript variable scoping to make sure that the new function has
      // access to the local variable named 'global'. We attach this function
      // to a map of referenced global variables in the context named 'g'.
      // (This is code that is generated by the app for the express purpose
      // of machine consumption, so we use terse variable names for simplicity.)
      // The generated JavaScript code then executes the function dereferenced
      // from the context with code that looks something like 'return c.g["v1"]'.
      if( !this.g) this.g = {};
      this.g[iName] = function() {
                        return globalValue.get('value');
                      };
      return 'c.g["' + iName + '"]()';
    }

    // If we don't match any variables we're in charge of,
    // let the base class have a crack at it.
    return sc_super();
  },
  
  /**
    Direct evaluation of the expression without an intervening compilation.
    This is unlikely to be used for plotted funtions where the expression is
    generally evaluated enough times to make compilation to JavaScript
    worthwhile, but we support it for consistency and completeness.
    @param    {String}    iName -- The variable name to be bound
    @returns  {Number}            The value of the specified variable or global
    @throws   {VarReferenceError} Base class throws VarReferenceError for
                                  variable names that are not recognized.
   */
  evaluateVariable: function( iName, iEvalContext) {

    // Check for a match with any global variables (e.g. sliders)
    var globalValue = DG.globalsController.findGlobalByName( iName);
    if( globalValue) {
      this.g[ iName] = true;  // add entry in map for dependency tracking
      return globalValue.get('value');
    }

    // If we don't match any variables we're in charge of,
    // let the base class have a crack at it.
    return sc_super();
  }
  
 });

