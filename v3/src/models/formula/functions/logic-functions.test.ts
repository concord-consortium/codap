import { UNDEF_RESULT } from "./function-utils"
import { math } from "./math"

describe("boolean", () => {
  it("works as expected", () => {
    const fn = math.compile("boolean(x)")
    expect(fn.evaluate({ x: undefined })).toBe(UNDEF_RESULT)
    expect(fn.evaluate({ x: "" })).toBe(UNDEF_RESULT)
    expect(fn.evaluate({ x: true })).toBe(true)
    expect(fn.evaluate({ x: false })).toBe(false)
    expect(fn.evaluate({ x: "true" })).toBe(true)
    expect(fn.evaluate({ x: "false" })).toBe(false)
    expect(fn.evaluate({ x: "TRUE" })).toBe(true)
    expect(fn.evaluate({ x: "FALSE" })).toBe(false)
    expect(fn.evaluate({ x: 1 })).toBe(true)
    expect(fn.evaluate({ x: 0 })).toBe(false)
    expect(fn.evaluate({ x: -1 })).toBe(true)
    expect(fn.evaluate({ x: NaN })).toBe(true)
    expect(fn.evaluate({ x: "0" })).toBe(false)
    // NaN !== 0
    expect(fn.evaluate({ x: "foo" })).toBe(true)
    expect(fn.evaluate({ x: "bar" })).toBe(true)
  })
})

describe("isBoolean", () => {
  it("works as expected", () => {
    const fn = math.compile("isBoolean(x)")
    expect(fn.evaluate({ x: undefined })).toBe(false)
    expect(fn.evaluate({ x: "" })).toBe(false)
    expect(fn.evaluate({ x: true })).toBe(true)
    expect(fn.evaluate({ x: false })).toBe(true)
    expect(fn.evaluate({ x: "true" })).toBe(true)
    expect(fn.evaluate({ x: "false" })).toBe(true)
    expect(fn.evaluate({ x: "TRUE" })).toBe(true)
    expect(fn.evaluate({ x: "FALSE" })).toBe(true)
    expect(fn.evaluate({ x: 1 })).toBe(false)
    expect(fn.evaluate({ x: 0 })).toBe(false)
    expect(fn.evaluate({ x: -1 })).toBe(false)
    expect(fn.evaluate({ x: NaN })).toBe(false)
    expect(fn.evaluate({ x: "0" })).toBe(false)
    expect(fn.evaluate({ x: "foo" })).toBe(false)
    expect(fn.evaluate({ x: "bar" })).toBe(false)
  })
})

describe("isBoundary", () => {
  it("works as expected", () => {
    const fn = math.compile("isBoundary(x)")
    expect(fn.evaluate({ x: undefined })).toBe(false)
    expect(fn.evaluate({ x: "" })).toBe(false)
    expect(fn.evaluate({ x: true })).toBe(false)
    expect(fn.evaluate({ x: false })).toBe(false)
    expect(fn.evaluate({ x: "true" })).toBe(false)
    expect(fn.evaluate({ x: "false" })).toBe(false)
    expect(fn.evaluate({ x: "TRUE" })).toBe(false)
    expect(fn.evaluate({ x: "FALSE" })).toBe(false)
    expect(fn.evaluate({ x: 1 })).toBe(false)
    expect(fn.evaluate({ x: 0 })).toBe(false)
    expect(fn.evaluate({ x: -1 })).toBe(false)
    expect(fn.evaluate({ x: NaN })).toBe(false)
    expect(fn.evaluate({ x: "0" })).toBe(false)
    expect(fn.evaluate({ x: "foo" })).toBe(false)
    expect(fn.evaluate({ x: "bar" })).toBe(false)
    expect(fn.evaluate({ x: { jsonBoundaryObject: {} } })).toBe(true)
  })
})

describe("isColor", () => {
  it("works as expected", () => {
    const fn = math.compile("isColor(x)")
    expect(fn.evaluate({ x: undefined })).toBe(false)
    expect(fn.evaluate({ x: "" })).toBe(false)
    expect(fn.evaluate({ x: true })).toBe(false)
    expect(fn.evaluate({ x: false })).toBe(false)
    expect(fn.evaluate({ x: "true" })).toBe(false)
    expect(fn.evaluate({ x: "false" })).toBe(false)
    expect(fn.evaluate({ x: "TRUE" })).toBe(false)
    expect(fn.evaluate({ x: "FALSE" })).toBe(false)
    expect(fn.evaluate({ x: 1 })).toBe(false)
    expect(fn.evaluate({ x: 0 })).toBe(false)
    expect(fn.evaluate({ x: -1 })).toBe(false)
    expect(fn.evaluate({ x: NaN })).toBe(false)
    expect(fn.evaluate({ x: "0" })).toBe(false)
    expect(fn.evaluate({ x: "foo" })).toBe(false)
    expect(fn.evaluate({ x: "bar" })).toBe(false)
    expect(fn.evaluate({ x: "#aabbcc" })).toBe(true)
    expect(fn.evaluate({ x: "#aabbcc88" })).toBe(true)
    expect(fn.evaluate({ x: "rgb(1, 2, 3)" })).toBe(true)
  })
})

describe("isDate", () => {
  it("works as expected", () => {
    const fn = math.compile("isDate(x)")
    expect(fn.evaluate({ x: undefined })).toBe(false)
    expect(fn.evaluate({ x: "" })).toBe(false)
    expect(fn.evaluate({ x: true })).toBe(false)
    expect(fn.evaluate({ x: false })).toBe(false)
    expect(fn.evaluate({ x: "true" })).toBe(false)
    expect(fn.evaluate({ x: "false" })).toBe(false)
    expect(fn.evaluate({ x: "TRUE" })).toBe(false)
    expect(fn.evaluate({ x: "FALSE" })).toBe(false)
    expect(fn.evaluate({ x: 1 })).toBe(false)
    expect(fn.evaluate({ x: 0 })).toBe(false)
    expect(fn.evaluate({ x: -1 })).toBe(false)
    expect(fn.evaluate({ x: NaN })).toBe(false)
    expect(fn.evaluate({ x: "0" })).toBe(false)
    expect(fn.evaluate({ x: "foo" })).toBe(false)
    expect(fn.evaluate({ x: "bar" })).toBe(false)
    expect(fn.evaluate({ x: new Date() })).toBe(true)
    expect(fn.evaluate({ x: "2024-10-22" })).toBe(true)
  })
})

describe("isFinite", () => {
  it("works as expected", () => {
    const fn = math.compile("isFinite(x)")
    expect(fn.evaluate({ x: undefined })).toBe(false)
    expect(fn.evaluate({ x: "" })).toBe(false)
    expect(fn.evaluate({ x: true })).toBe(true)
    expect(fn.evaluate({ x: false })).toBe(true)
    expect(fn.evaluate({ x: "true" })).toBe(false)
    expect(fn.evaluate({ x: "false" })).toBe(false)
    expect(fn.evaluate({ x: "TRUE" })).toBe(false)
    expect(fn.evaluate({ x: "FALSE" })).toBe(false)
    expect(fn.evaluate({ x: 1 })).toBe(true)
    expect(fn.evaluate({ x: 0 })).toBe(true)
    expect(fn.evaluate({ x: -1 })).toBe(true)
    expect(fn.evaluate({ x: NaN })).toBe(false)
    expect(fn.evaluate({ x: "0" })).toBe(true)
    expect(fn.evaluate({ x: "foo" })).toBe(false)
    expect(fn.evaluate({ x: "bar" })).toBe(false)
  })
})

describe("isMissing", () => {
  it("works as expected", () => {
    const fn = math.compile("isMissing(x)")
    expect(fn.evaluate({ x: undefined })).toBe(true)
    expect(fn.evaluate({ x: "" })).toBe(true)
    expect(fn.evaluate({ x: true })).toBe(false)
    expect(fn.evaluate({ x: false })).toBe(false)
    expect(fn.evaluate({ x: "true" })).toBe(false)
    expect(fn.evaluate({ x: "false" })).toBe(false)
    expect(fn.evaluate({ x: "TRUE" })).toBe(false)
    expect(fn.evaluate({ x: "FALSE" })).toBe(false)
    expect(fn.evaluate({ x: 1 })).toBe(false)
    expect(fn.evaluate({ x: 0 })).toBe(false)
    expect(fn.evaluate({ x: -1 })).toBe(false)
    expect(fn.evaluate({ x: NaN })).toBe(false)
    expect(fn.evaluate({ x: "0" })).toBe(false)
    expect(fn.evaluate({ x: "foo" })).toBe(false)
    expect(fn.evaluate({ x: "bar" })).toBe(false)
  })
})

describe("isNumber", () => {
  it("works as expected", () => {
    const fn = math.compile("isNumber(x)")
    expect(fn.evaluate({ x: undefined })).toBe(false)
    expect(fn.evaluate({ x: "" })).toBe(false)
    expect(fn.evaluate({ x: true })).toBe(true)
    expect(fn.evaluate({ x: false })).toBe(true)
    expect(fn.evaluate({ x: "true" })).toBe(false)
    expect(fn.evaluate({ x: "false" })).toBe(false)
    expect(fn.evaluate({ x: "TRUE" })).toBe(false)
    expect(fn.evaluate({ x: "FALSE" })).toBe(false)
    expect(fn.evaluate({ x: 1 })).toBe(true)
    expect(fn.evaluate({ x: 0 })).toBe(true)
    expect(fn.evaluate({ x: -1 })).toBe(true)
    expect(fn.evaluate({ x: NaN })).toBe(false)
    expect(fn.evaluate({ x: "0" })).toBe(true)
    expect(fn.evaluate({ x: "foo" })).toBe(false)
    expect(fn.evaluate({ x: "bar" })).toBe(false)
  })
})
