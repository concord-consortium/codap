import {
  addDisposer, addMiddleware, getSnapshot, IJsonPatch, Instance,
  isActionContextThisOrChildOf, isAlive, recordPatches, tryResolve
} from "mobx-state-tree"
import { nanoid } from "nanoid"
import { IDocumentContentModel } from "../document/document-content"
import { TreeManagerAPI } from "./tree-manager-api"
import { TreePatchRecordSnapshot } from "./history"
import { Tree } from "./tree"
import {
  CallEnv, getActionModelName, getActionPath, isActionFromManager, isValidCallEnv, runningCalls,
  SharedModelModifications
} from "./tree-types"
import { createActionTrackingMiddleware3, IActionTrackingMiddleware3Call } from "./create-action-tracking-middleware-3"

export class TreeMonitor {
  private tree: Instance<typeof Tree>
  private manager: TreeManagerAPI
  private enabled = false

  constructor(tree: Instance<typeof Tree>,  manager: TreeManagerAPI, includeHooks: boolean) {
    // We don't care how `this` is handled by createActionTrackingMiddleware
    // so we save it as self to make sure we have access to it in onFinish so we
    // call `recordAction`
    // eslint-disable-next-line @typescript-eslint/no-this-alias
    const self = this
    this.tree = tree
    this.manager = manager

    const treeMonitorMiddleware = createActionTrackingMiddleware3<CallEnv>({
      filter(call) {

        // Note: If we switch to a synchronizing readonly documents over the network using
        // the history instead of the document content, then we'll need to enable
        // the middleware even for readOnly documents. So then `enabled` would just mean that
        // the recording of events is enabled.
        if (!self.enabled || call.env) {
          // monitoring is disabled or we are already recording
          return false
        }

        // Ignore the special snapshot actions, this will pick up other actions
        // with the same name, so these are now reserved action names.
        // A better approach would be to use type.snapshotProcessor which provides
        // access to the model instance in its postProcess function
        // this would avoid the need for completeSnapshot, and will probably be
        // more memory efficient, and it would remove the need for this special
        // handling
        const actionName = call.actionCall.name
        if (actionName === "completeSnapshot" || actionName === "prepareSnapshot") {
          return false
        }
        return true
      },
      onStart(call) {
        // Add this call to our global WeakMap so other functions can
        // modify these calls.
        runningCalls.set(call.actionCall, call)

        // DEBUG:
        // console.log("onStart", getActionPath(call))
        const sharedModelModifications: SharedModelModifications = {}

        // Save the sharedModelMap before any changes are made this way if
        // a link is removed we can identify the old tile before the change
        // FIXME: this breaks the abstraction, and means the tree monitor
        // wouldn't work in an iframe tree.
        const document = (tree as any).content as IDocumentContentModel
        const initialSharedModelMap = getSnapshot(document.sharedModelMap)

        let historyEntryId
        let exchangeId

        // We are looking for specific actions which we know include a
        // historyEntryId and exchangeId as their first two arguments. This
        // is so we can link all of the changes with this same
        // historyEntryId and exchangeId. These actions are all defined on
        // the common `Tree` model which is composed into the actual root of
        // the MST tree. So individual trees should not be defining these
        // actions themselves.
        //
        // TODO: We might be able use the `decorate` feature of MST to make
        // it more clear in the Tile model that these actions are special.
        if (isActionFromManager(call)) {
          historyEntryId = call.actionCall.args[0]
          exchangeId = call.actionCall.args[1]
        } else {
          historyEntryId = nanoid()
          exchangeId = nanoid()
        }

        const recorder = recordPatches(
          call.actionCall.tree,
          (_patch, _inversePatch, actionContext) => {
            // This function should return true if the patch should be recorded
            // This function is basically an onPatch handler

            // Only pay attention to patches that were generated by this action or children of this action
            if (!actionContext ||
                (!!actionContext && !isActionContextThisOrChildOf(actionContext, call.actionCall.id))) {
                return false
            }

            // See if the patch is modifying one of the mounted shared
            // models or shared model views.
            //
            // If it is a shared model view, then don't record this
            // patch.
            //
            // Also track the modification so we can notify the tree
            // when the action is done. The tree needs to know about
            // these modifications so it can tell the tiles to update
            // themselves based on the changes in the shared model or
            // shared model view. And the manager needs to know about
            // the shared model changes so it can send them any other
            // trees.
            //
            // This is kind of a hack, but we identify the shared model
            // changes based on their path in the document.
            // CLUE doesn't support shared model views yet, so we just
            // look for shared models in the sharedModelMap of the
            // document.
            //
            // When a new shared model is added to the document the path will be
            //   /content/sharedModelMap/${sharedModelId}
            // When a shared model is linked or unlinked to a tile the path will be:
            //   /content/sharedModelMap/${sharedModelId}/tiles/[index]
            const pathMatch = _patch.path.match(/(.*\/content\/sharedModelMap\/[^/]+)/)
            if (pathMatch) {
              const sharedModelPath = pathMatch[1]

              if (!sharedModelModifications[sharedModelPath]) {
                sharedModelModifications[sharedModelPath] = 1
              } else {
                // increment the number of modifications made to the shared model
                sharedModelModifications[sharedModelPath]++
              }

              // TODO: If this is a shared model view, we shouldn't record the
              // patch, so we should return false.
              //
              // Currently CLUE doesn't support shared model views, so this isn't
              // implemented yet.
            }

            return true
          }
        )
        recorder.resume()

        call.env = {
          recorder,
          initialSharedModelMap,
          sharedModelModifications,
          historyEntryId,
          exchangeId,
          // by default, actions dirty the document and are undoable
          // withoutUndo() and withoutDirtyingDocument() can be used to alter these defaults
          undoable: true
        }
      },
      onFinish(call, error) {
        const env = call.env
        if (!isValidCallEnv(env)) {
          throw new Error(`The call.env is corrupted: ${JSON.stringify(env)}`)
        }
        // DEBUG:
        // console.log("onFinish", getActionPath(call))

        call.env = undefined

        const { recorder } = env
        recorder.stop()

        if (error === undefined) {
          // recordAction is async
          self.recordAction(call, env)
        } else {
          // TODO: This is a new feature that is being added to the tree:
          // any errors that happen during an action will cause the tree to revert back to
          // how it was before.
          // This might be a good thing to do, but it needs to be analyzed to see what happens
          // with the shared models when the patches are undone.
          recorder.undo()
        }
      }
    })

    // I'd guess in our case we always want to include hooks. If a model makes some
    // changes to its state when it is added to the tree during an action we'd want that
    // to be part of the undo stack.
    //
    // TODO: however perhaps this setting is just for the initial action. So perhaps even
    // without this the creation of a model would be recorded by the recorder if it was
    // a done in a child action. So we should do some experimentation with middleware
    // the recorder and hooks.
    const middlewareDisposer = addMiddleware(tree, treeMonitorMiddleware, includeHooks)

    // We might need an option to not add this disposer, but it seems it would generally
    // ge a good thing to do.
    addDisposer(tree, middlewareDisposer)
  }

  enableMonitoring() {
    this.enabled = true
  }

  disableMonitoring() {
    this.enabled = false
  }

  // recordAction is async because it needs to wait for the manager to
  // respond, to the addHistoryEntry, startExchange, and
  // handleSharedModelChanges calls before it can call addTreePatchRecord. The
  // recorded changes are safe because each action creates a new recorder, and
  // the recorder stores the changes. So even if another action is triggered
  // before the changes are sent it will be OK.
  //
  // If a shared model has been modified, the state of the shared model is
  // captured just before it is sent so the shared model might have been
  // modified after recordAction was was called. This is OK because this
  // shared model state sending is just to synchronize other views of the
  // shared model in other trees. The actual changes to the shared model are
  // stored in the recorder.
  async recordAction(call: IActionTrackingMiddleware3Call<CallEnv>, env: CallEnv) {
    const { recorder, initialSharedModelMap, sharedModelModifications, historyEntryId,
      exchangeId, noDirty, undoable, customPatches, clientData } = env
    if (!isActionFromManager(call)) {
      // We record the start of the action even if it doesn't have any
      // patches. This is useful when an action only modifies the shared
      // tree
      //
      // If the manager triggered the action then the manager already
      // added the history entry.
      //
      await this.manager.addHistoryEntry({
        id: historyEntryId,
        exchangeId,
        tree: this.tree.treeId,
        model: getActionModelName(call),
        action: getActionPath(call),
        noDirty,
        undoable,
        customPatches,
        clientData
      })
    }

    // Call the shared model notification function if there are changes.
    // This is needed so the changes can be sent to the manager, and so
    // the changes can trigger a update/sync of the tile model.
    //
    // TODO: If there are multiple shared model changes, we might want
    // to send them all to the tree at the same time, that way it can
    // inform the tiles of all changes at the same time.
    const exchangesToProcess: { id: string, path: string }[] = []
    for (const [sharedModelPath, numModifications] of Object.entries(sharedModelModifications)) {
      if (numModifications > 0) {
        // If a shared model has been deleted, we can't run these callbacks without errors,
        // so we bail out now.  May need improvement if tiles need to be notified about
        // deleted shared models.
        if (!isAlive(this.tree)) {
          // The tree might have been destroyed. This happens during tests.
          return
        }
        try {
          tryResolve(this.tree, `${sharedModelPath}/sharedModel`)
        } catch {
          continue
        }
        // Run the callbacks tracking changes to the shared model.
        // We need to wait for these to complete because the manager
        // needs to know when this history entry is complete. If it
        // gets the addTreePatchRecord before any changes from the
        // shared models it will mark the entry complete too soon.
        //
        // A new exchangeId needs to be created and startExchange
        // needs to be called because handleSharedModelChanges is
        // treated the same as a call from the TreeManager. As
        // described above the middleware expects the exchange to
        // have already been started. handleSharedModelChanges needs
        // to be treated this way so the same historyEntryId is used
        // by the middleware. This way any changes triggered by the
        // shared model update are recorded in the same HistoryEntry
        //
        const sharedModelChangesExchangeId = nanoid()
        // TODO: we get here with this.manager not alive during some jest tests ¯\_(ツ)_/¯
        if (!isAlive(this.manager)) return
        await this.manager.startExchange(historyEntryId, sharedModelChangesExchangeId,
          "recordAction.sharedModelChanges")

        exchangesToProcess.push({ id: sharedModelChangesExchangeId, path: sharedModelPath })
      }
    }

    // The tree might have been destroyed in the meantime. This happens during tests.
    // In that case we bail and don't record anything
    if (!isAlive(this.tree)) {
      return
    }

    // TODO: CLUE Specific filtering of 'changeCount', should we record
    // this or not?
    const filterChangeCount = (patch: IJsonPatch) => !patch.path.match(/\/changeCount/)
    const patches = recorder.patches.filter(filterChangeCount)
    const inversePatches = recorder.inversePatches.filter(filterChangeCount)

    // Always send the record to the manager even if there are no
    // patches. This API is how the manager knows the exchangeId is finished.
    const record: TreePatchRecordSnapshot = {
      tree: this.tree.treeId,
      action: getActionPath(call),
      patches,
      inversePatches,
    }
    this.manager.addTreePatchRecord(historyEntryId, exchangeId, record)

    for (const exchange of exchangesToProcess) {
      // Now that the patches have been recorded, we can process the shared model changes
      // Recursion: handleSharedModelChanges is an action on the
      // tree, and we are currently in a middleware that is
      // monitoring actions on that tree. At this point in the
      // middleware we are finishing a different action. Calling
      // handleSharedModelChanges starts a new top level action:
      // an action with no parent actions. This is what we want so
      // we can record any changes made to the tree as part of the
      // undo entry. I don't know if calling an action from a
      // middleware is an officially supported or tested approach.
      // It is working now. If it stops working we could delay the
      // call to handleSharedModelChanges with a setTimeout.
      //
      // It is recursive because we will end up back in this
      // recordAction function. Because we are awaiting
      // handleSharedModelChanges that second recursive
      // recordAction will get kicked off before this call to
      // handleSharedModelChanges returns. The tree's
      // implementation of handleSharedModelChanges should not
      // modify the shared model itself or we could get into an
      // infinite loop.
      //
      // Within this recursive call to recordAction,
      // addTreePatchRecord will be called. This is how the
      // startExchange above is closed out.
      await this.tree.handleSharedModelChanges(historyEntryId, exchange.id,
        call, exchange.path, initialSharedModelMap)
    }

  }
}
